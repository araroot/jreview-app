<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Êó•Êú¨Ë™û">

  <link rel="apple-touch-icon" href="icon-180.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">

  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">

  <link rel="manifest" href="manifest-review.json">

  <title>Japanese Vocabulary Review</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; flex-direction: column; color: white; overflow-x: hidden; }
    .header { padding: 20px; text-align: center; background: rgba(0, 0, 0, 0.2); }
    .header h1 { font-size: 24px; margin-bottom: 10px; }
    .stats { display: flex; justify-content: center; gap: 20px; font-size: 14px; opacity: 0.9; }
    .stat-item { display: flex; flex-direction: column; align-items: center; }
    .stat-number { font-size: 24px; font-weight: bold; }
    .main-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; position: relative; }
    @media (max-height: 700px) { .main-container { padding: 10px; } }
    .progress-bar { width: 100%; max-width: 400px; height: 8px; background: rgba(255, 255, 255, 0.2); border-radius: 10px; margin-bottom: 30px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 10px; transition: width 0.3s ease; }
    .card-container { width: 100%; max-width: 400px; height: 400px; position: relative; perspective: 1000px; }
    @media (max-height: 700px) { .card-container { height: 320px; } }
    .flashcard { width: 100%; height: 100%; background: white; border-radius: 20px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 40px; cursor: pointer; transition: transform 0.3s ease; position: absolute; touch-action: pan-y; }
    .flashcard.flipped .card-front { display: none; }
    .flashcard.flipped .card-back { display: flex; }
    .card-front, .card-back { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
    .card-back { display: none; }
    .delete-btn { position: absolute; top: 15px; right: 15px; background: transparent; color: #9ca3af; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; z-index: 10; opacity: 0.6; }
    .delete-btn:hover { opacity: 1; transform: scale(1.1); }
    .delete-btn:active { transform: scale(0.95); }
    .context { font-size: 14px; color: #6b7280; text-align: center; margin-top: 15px; line-height: 1.5; font-style: italic; max-height: 80px; overflow-y: auto; }
    .word-front { font-size: 64px; font-weight: bold; color: #1f2937; margin-bottom: 10px; }
    @media (max-height: 700px) { .word-front { font-size: 48px; } }
    .hint { font-size: 14px; color: #6b7280; margin-top: 10px; }
    .answer { margin-top: 15px; }
    .word-display { font-size: 36px; font-weight: bold; color: #3b82f6; margin-bottom: 6px; }
    .reading-display { font-size: 16px; color: #6b7280; margin-bottom: 10px; }
    .meaning-display { font-size: 18px; color: #1f2937; text-align: center; }
    .context-back { margin-top: 15px; padding: 12px; background: #f3f4f6; border-radius: 10px; max-width: 100%; }
    @media (max-height: 700px) { .context-back { margin-top: 10px; padding: 10px; } }
    .context-sentence { font-size: 14px; color: #1f2937; margin-bottom: 8px; line-height: 1.4; }
    .context-translation { font-size: 13px; color: #6b7280; font-style: italic; line-height: 1.3; }
    .action-buttons { display: flex; gap: 15px; margin-top: 20px; }
    .btn { padding: 15px 30px; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; color: white; }
    .btn-hard { background: linear-gradient(135deg, #ef4444, #dc2626); }
    .btn-good { background: linear-gradient(135deg, #f59e0b, #d97706); }
    .btn-easy { background: linear-gradient(135deg, #10b981, #059669); }
    .btn:active { transform: scale(0.95); }
    .completion-screen { display: none; text-align: center; }
    .completion-screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .completion-emoji { font-size: 80px; margin-bottom: 20px; }
    .completion-title { font-size: 32px; font-weight: bold; margin-bottom: 10px; }
    .completion-message { font-size: 18px; opacity: 0.9; margin-bottom: 30px; }
    .login-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; }
    .login-screen.hidden { display: none; }
    .login-btn { padding: 15px 40px; background: white; color: #667eea; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer; }
    .tap-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 14px; opacity: 0.7; animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 0.3; } }
    .swipe-indicator { display: flex; justify-content: space-between; width: 100%; max-width: 400px; margin-top: 20px; font-size: 12px; opacity: 0.7; }
    .nav-buttons { display: flex; gap: 15px; margin-top: 20px; justify-content: center; }
    .nav-btn { background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); color: white; padding: 12px 24px; border-radius: 12px; font-size: 18px; cursor: pointer; transition: all 0.2s ease; font-weight: 600; }
    .nav-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.5); }
    .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .nav-btn:active:not(:disabled) { transform: scale(0.95); }
  </style>
</head>
<body>
  <div class="header">
    <h1>üìö Japanese Review V34</h1>
    <div class="stats">
      <div class="stat-item"><div class="stat-number" id="dueCount">0</div><div>Due Today</div></div>
      <div class="stat-item"><div class="stat-number" id="reviewedCount">0</div><div>Reviewed</div></div>
      <div class="stat-item"><div class="stat-number" id="streakCount">0</div><div>üî• Streak</div></div>
    </div>
  </div>

  <div class="main-container">
    <div class="login-screen" id="loginScreen">
      <h2>Welcome! üëã</h2>
      <p>Enter your User ID from the extension</p>
      <input type="text" id="userIdInput" placeholder="user_xxxxx" style="padding: 12px; border-radius: 8px; border: 2px solid white; font-size: 16px; width: 250px; margin-bottom: 15px;">
      <p style="margin-top: 15px;">OpenAI API Key (for AI curation)</p>
      <input type="password" id="apiKeyInput" placeholder="sk-..." style="padding: 12px; border-radius: 8px; border: 2px solid white; font-size: 16px; width: 250px; margin-bottom: 15px;">
      <button class="login-btn" id="loginBtn">Continue</button>
      <p style="font-size: 12px; opacity: 0.7; margin-top: 10px;">Find your User ID: Click extension icon ‚Üí Copy ID<br>Get API key: <a href="https://platform.openai.com/api-keys" target="_blank" style="color: white;">OpenAI API Keys</a></p>
    </div>

    <div class="login-screen" id="showListScreen" style="display: none;">
      <h2>Choose a Show üì∫</h2>
      <p style="margin-bottom: 20px; font-size: 14px;">Select a show to review its vocabulary</p>
      <button class="login-btn" id="reviewAllShows" style="margin-bottom: 15px; background: linear-gradient(135deg, #10b981, #059669); font-size: 16px;">üìÖ Review All Shows (Due: <span id="allShowsDueCount">0</span>)</button>
      <button class="login-btn" id="practiceCommonVerbs" style="margin-bottom: 20px; background: linear-gradient(135deg, #f59e0b, #d97706); font-size: 16px;">üî• Practice Common Verbs</button>
      <div id="showList" style="max-height: 400px; overflow-y: auto; margin-bottom: 15px;"></div>
    </div>

    <div class="login-screen" id="showOptionsScreen" style="display: none;">
      <h2 id="showOptionsTitle">üì∫ Show Name</h2>
      <p style="margin-bottom: 20px; font-size: 14px;">Smart practice sessions tailored to your level</p>
      <p style="margin-bottom: 30px; font-size: 13px; opacity: 0.8;">AI Curated: Balanced Hard, Good, and Easy words.</p>
      <button class="login-btn" id="optionSmart20" style="margin-bottom: 15px; background: linear-gradient(135deg, #3b82f6, #2563eb);">üéØ Practice 20 Words</button>
      <button class="login-btn" id="optionSmart50" style="margin-bottom: 15px; background: linear-gradient(135deg, #8b5cf6, #7c3aed);">üöÄ Practice 50 Words</button>
      <button class="login-btn" id="backToShowsBtn" style="margin-top: 10px; background: rgba(255,255,255,0.2);">‚Üê Back to Shows</button>
    </div>

    <div id="reviewScreen" style="display: none; width: 100%;">
      <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
      <div class="card-container">
        <div class="flashcard" id="flashcard">
          <div class="card-front">
            <button class="delete-btn" id="deleteBtnFront" title="Delete this word">üóëÔ∏è</button>
            <div class="word-front" id="wordFront"></div>
            <div class="context" id="contextDisplay"></div>
          </div>
          <div class="card-back">
            <div class="answer">
              <div class="word-display" id="wordDisplay"></div>
              <div class="reading-display" id="readingDisplay"></div>
              <div class="meaning-display" id="meaningDisplay"></div>
            </div>
            <div class="context-back" id="contextBack">
              <div class="context-sentence" id="contextSentenceBack"></div>
              <div class="context-translation" id="contextTranslation"></div>
            </div>
            <div class="action-buttons">
              <button class="btn btn-hard" id="btnHard">üîÑ Hard</button>
              <button class="btn btn-good" id="btnGood">‚úì Good</button>
              <button class="btn btn-easy" id="btnEasy">‚úì‚úì Easy</button>
            </div>
          </div>
        </div>
      </div>
      <div class="nav-buttons">
        <button class="nav-btn" id="btnPrevious">‚Üê Previous</button>
        <button class="nav-btn" id="btnNext">Next ‚Üí</button>
      </div>
      <div class="swipe-indicator">
        <span>‚Üê Hard (1 day)</span><span>Good (3 days)</span><span>Easy (7 days) ‚Üí</span>
      </div>
    </div>

    <div class="completion-screen" id="completionScreen">
      <div class="completion-emoji">üéâ</div>
      <div class="completion-title">Session Complete!</div>
      <div class="completion-message" id="sessionSummary" style="font-size: 16px; margin-bottom: 20px;">You reviewed <span id="summaryTotal">0</span> words</div>
      <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 25px; font-size: 14px;">
        <div style="text-align: center;"><div style="font-size: 28px; font-weight: bold; color: #ef4444;" id="summaryHard">0</div><div style="opacity: 0.8;">üîÑ Hard</div></div>
        <div style="text-align: center;"><div style="font-size: 28px; font-weight: bold; color: #10b981;" id="summaryGood">0</div><div style="opacity: 0.8;">‚úì Good</div></div>
        <div style="text-align: center;"><div style="font-size: 28px; font-weight: bold; color: #3b82f6;" id="summaryEasy">0</div><div style="opacity: 0.8;">‚úì‚úì Easy</div></div>
        <div style="text-align: center;" id="summaryDeletedContainer" style="display: none;"><div style="font-size: 28px; font-weight: bold; color: #9ca3af;" id="summaryDeleted">0</div><div style="opacity: 0.8;">üóëÔ∏è Deleted</div></div>
      </div>
      <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; font-size: 13px; line-height: 1.6; margin-bottom: 20px; max-width: 400px;">
        <strong>ü§ñ Session Report:</strong><br>
        ‚Ä¢ Words successfully curated by AI.<br>
        ‚Ä¢ Mixed difficulty for optimal retention.<br>
      </div>
      <button type="button" class="btn btn-good" id="continueBtn" onclick="window.handleContinue && window.handleContinue()" style="padding: 15px 40px; cursor: pointer; -webkit-tap-highlight-color: rgba(0,0,0,0.2); z-index: 9999; position: relative;">Continue ‚Üí</button>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="js/common-verbs.js"></script>

  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDQgZ4XKuEbQ6mincj6R8bX6gBH_CUETUY",
      authDomain: "japanese-learning-app-dc19d.firebaseapp.com",
      databaseURL: "https://japanese-learning-app-dc19d-default-rtdb.firebaseio.com",
      projectId: "japanese-learning-app-dc19d",
      storageBucket: "japanese-learning-app-dc19d.firebasestorage.app",
      messagingSenderId: "68430245068",
      appId: "1:68430245068:web:c40f7e0a6717f054b4a669"
    };
  
    // Initialize Firebase
    let app, auth, database;
    let currentWords = [];
    let currentIndex = 0;
    let isFlipped = false;
    let reviewedToday = 0;
    let currentUserId = null;

    let sessionStats = { hard: 0, good: 0, easy: 0, deleted: 0, total: 0 };

    // Screen Switching Helper
    function switchScreen(screenId) {
        const screens = ['loginScreen', 'showListScreen', 'showOptionsScreen', 'reviewScreen', 'completionScreen'];
        screens.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            el.style.display = 'none';
            el.style.visibility = 'hidden';
            el.style.opacity = '0';
            el.classList.remove('active');
        });

        const target = document.getElementById(screenId);
        if (!target) return;

        if (screenId === 'completionScreen') {
            target.style.display = 'flex';
            target.classList.add('active');
        } else if (screenId === 'reviewScreen') {
            target.style.display = 'block';
        } else {
            target.style.display = 'flex';
        }

        target.style.visibility = 'visible';
        setTimeout(() => { target.style.opacity = '1'; }, 10);
    }

    function initFirebase() {
      try {
        app = firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        database = firebase.database();
        return true;
      } catch (error) {
        console.error("Firebase init error:", error);
        alert("Please configure Firebase credentials in the HTML file");
        return false;
      }
    }

    document.getElementById('loginBtn').addEventListener('click', async () => {
      try {
        const userId = document.getElementById('userIdInput').value.trim();
        const apiKey = document.getElementById('apiKeyInput').value.trim();
        if (!userId || !apiKey) { alert("Please enter User ID and API Key"); return; }

        currentUserId = userId;
        localStorage.setItem('savedUserId', userId);
        localStorage.setItem('openaiApiKey', apiKey);

        switchScreen('showListScreen');
        await loadShowList();
      } catch (error) {
        console.error("Login error:", error);
        alert("Error: " + error.message);
      }
    });

    let selectedShow = null;

    document.getElementById('reviewAllShows').addEventListener('click', async () => {
      switchScreen('reviewScreen');
      await loadWords();
    });

    document.getElementById('practiceCommonVerbs').addEventListener('click', async () => {
      await loadCommonVerbsPractice();
    });

    document.getElementById('backToShowsBtn').addEventListener('click', () => {
      switchScreen('showListScreen');
    });

    document.getElementById('optionSmart20').addEventListener('click', async () => {
      if (!selectedShow) return;
      await loadSmartPractice(selectedShow.name, selectedShow.season, selectedShow.episode, 20);
    });

    document.getElementById('optionSmart50').addEventListener('click', async () => {
      if (!selectedShow) return;
      await loadSmartPractice(selectedShow.name, selectedShow.season, selectedShow.episode, 50);
    });

    async function loadShowList() {
      try {
        const url = `${firebaseConfig.databaseURL}/users/${currentUserId}/words.json`;
        const response = await fetch(url);
        const words = await response.json();

        if (!words) {
          document.getElementById('showList').innerHTML = '<p style="color: white; text-align: center; padding: 20px;">No words saved yet!</p>';
          document.getElementById('allShowsDueCount').textContent = '0';
          return;
        }

        const allWords = Object.values(words);
        const now = Date.now();
        const dueCount = allWords.filter(word => !word.mastered && word.nextReview <= now).length;
        document.getElementById('allShowsDueCount').textContent = dueCount;

        const showMap = {};
        allWords.forEach(word => {
          if (word.show) {
            const key = `${word.show}_S${word.season}E${word.episode}`;
            if (!showMap[key]) showMap[key] = { name: word.show, season: word.season, episode: word.episode, count: 0 };
            showMap[key].count++;
          }
        });

        const showListEl = document.getElementById('showList');
        showListEl.innerHTML = '';
        const shows = Object.values(showMap).sort((a, b) => b.count - a.count);

        if (shows.length === 0) {
          showListEl.innerHTML = '<p style="color: white; text-align: center; padding: 20px;">No shows tagged yet!</p>';
          return;
        }

        shows.forEach(show => {
          const btn = document.createElement('button');
          btn.className = 'login-btn';
          btn.style.marginBottom = '10px';
          btn.style.width = '100%';
          btn.textContent = `${show.name} S${show.season}E${show.episode} (${show.count} words)`;
          btn.addEventListener('click', () => showOptionsForShow(show));
          showListEl.appendChild(btn);
        });
      } catch (error) {
        console.error('Error loading show list:', error);
      }
    }

    async function showOptionsForShow(show) {
      selectedShow = show;
      switchScreen('showOptionsScreen');
      document.getElementById('showOptionsTitle').textContent = `üì∫ ${show.name} S${show.season}E${show.episode}`;
    }

    // --- IMPROVED AI RANKING ---
    async function rankWordsWithAI(words, knownWords, deletedWords, targetCount) {
      try {
        // Send more words than needed so AI has options
        const wordsToConsider = words.slice(0, 100); 

        const wordData = wordsToConsider.map(word => {
          let difficultyMarking = 'New';
          if (word.difficulty === 'easy') difficultyMarking = 'Easy';
          else if (word.difficulty === 'good') difficultyMarking = 'Good';
          else if (word.difficulty === 'hard') difficultyMarking = 'Hard';
          else if (word.reviewCount > 0) difficultyMarking = 'Good'; // Default to Good if reviewed but no tag

          return {
            word: word.word,
            reading: word.reading,
            meaning: word.meaning,
            status: difficultyMarking
          };
        });

        // Prompt specifically designed for distribution
        const prompt = `Act as an expert Japanese teacher creating a Spaced Repetition session.
        
        I need exactly ${targetCount} words selected from the AVAILABLE WORDS list below.
        
        REQUIRED DISTRIBUTION:
        1. ~15-20% HARD or NEW words (Status: "Hard" or "New"). These are critical for learning.
        2. ~50% GOOD words (Status: "Good"). These need reinforcing.
        3. ~30% EASY words (Status: "Easy"). These are for confidence and speed.

        INSTRUCTIONS:
        - You MUST return a JSON array of exactly ${targetCount} strings.
        - Prioritize "Hard" and "New" words first to ensure the session is challenging.
        - Do not just pick the most common words. Pick words based on the statuses provided to match the distribution.
        - If you run out of "Hard" words, fill with "Good".
        - Exclude words found in the DELETED WORDS list.

        DELETED WORDS (Ignore these): ${deletedWords.slice(0, 50).join(', ')}

        AVAILABLE WORDS:
        ${JSON.stringify(wordData)}

        Return ONLY JSON array: ["word1", "word2", ...]`;

        const apiKey = localStorage.getItem('openaiApiKey');
        if (!apiKey) { alert('OpenAI API key not found!'); return null; }

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [{ role: "user", content: prompt }],
            temperature: 0.4,
            max_tokens: 2000 // Increased tokens to prevent cutoff
          })
        });

        if (!response.ok) throw new Error(`OpenAI API error: ${response.status}`);

        const data = await response.json();
        let aiResponse = data.choices[0].message.content.trim();
        
        if (aiResponse.startsWith('```json')) aiResponse = aiResponse.replace(/^```json\n/, '').replace(/\n```$/, '');
        else if (aiResponse.startsWith('```')) aiResponse = aiResponse.replace(/^```\n/, '').replace(/\n```$/, '');

        const rankedWordNames = JSON.parse(aiResponse);
        
        // Map names back to objects
        let rankedWords = rankedWordNames
          .map(wordName => words.find(w => w.word === wordName))
          .filter(w => w !== undefined);

        // --- BACKFILL MECHANISM ---
        // If AI returns fewer than targetCount, fill the rest from the original list
        if (rankedWords.length < targetCount) {
            console.log(`AI returned only ${rankedWords.length} words. Backfilling to reach ${targetCount}...`);
            const existingIds = new Set(rankedWords.map(w => w.id));
            
            for (const word of words) {
                if (rankedWords.length >= targetCount) break;
                if (!existingIds.has(word.id)) {
                    rankedWords.push(word);
                    existingIds.add(word.id);
                }
            }
        }

        return rankedWords;

      } catch (error) {
        console.error('AI ranking error:', error);
        alert('AI ranking failed, falling back to standard list.');
        return null; // Triggers fallback in caller
      }
    }

    async function loadSmartPractice(showName, season, episode, count) {
      try {
        const url = `${firebaseConfig.databaseURL}/users/${currentUserId}/words.json`;
        const response = await fetch(url);
        const allWords = await response.json();

        if (!allWords) { alert("No words saved yet!"); switchScreen('showListScreen'); return; }

        const allWordsArray = Object.entries(allWords).map(([id, word]) => ({ id, ...word }));
        
        // Filter for this show
        const showWords = allWordsArray.filter(word =>
          word.show === showName &&
          word.season === season &&
          word.episode === episode &&
          !word.mastered
        );

        if (showWords.length === 0) { alert(`No words found for this episode.`); switchScreen('showListScreen'); return; }

        // Recency Filter (2 hours)
        const eligibleWords = showWords.filter(word => {
          const hoursSince = (Date.now() - (word.lastReviewed || 0)) / (1000 * 60 * 60);
          return !(hoursSince < 2 && word.lastReviewed);
        });

        if (eligibleWords.length === 0) { alert("All words recently reviewed."); switchScreen('showOptionsScreen'); return; }

        // If total eligible words are fewer than target, just take them all
        if (eligibleWords.length <= count) {
            currentWords = eligibleWords;
        } else {
            // Get deleted words
            const deletedUrl = `${firebaseConfig.databaseURL}/users/${currentUserId}/deletedWords.json`;
            const deletedResponse = await fetch(deletedUrl);
            const deletedData = await deletedResponse.json();
            const deletedWords = deletedData ? Object.values(deletedData).map(w => w.word) : [];

            // AI Selection
            const rankedWords = await rankWordsWithAI(eligibleWords, new Set(), deletedWords, count);
            
            if (rankedWords && rankedWords.length > 0) {
                currentWords = rankedWords;
            } else {
                // Fallback if AI fails completely
                currentWords = eligibleWords.slice(0, count);
            }
        }

        todaysWords = [];
        sessionStats = { hard: 0, good: 0, easy: 0, deleted: 0, total: 0 };
        currentIndex = 0;
        reviewedToday = 0;
        document.getElementById('dueCount').textContent = currentWords.length;
        document.getElementById('reviewedCount').textContent = 0;

        switchScreen('reviewScreen');
        showCurrentCard();

      } catch (error) {
        console.error("Smart practice error:", error);
        alert("Error: " + error.message);
      }
    }

    async function loadWords() {
      try {
        if (!currentUserId) { alert("User ID not set"); return; }
        const url = `${firebaseConfig.databaseURL}/users/${currentUserId}/words.json`;
        const response = await fetch(url);
        const words = await response.json();

        if (!words) { switchScreen('completionScreen'); document.querySelector('.completion-message').textContent = "No words saved yet."; return; }

        const now = Date.now();
        currentWords = Object.entries(words)
          .map(([id, word]) => ({ id, ...word }))
          .filter(word => !word.mastered && word.nextReview <= now)
          .sort((a, b) => a.nextReview - b.nextReview)
          .slice(0, 15);

        if (currentWords.length === 0) {
           switchScreen('completionScreen');
           document.querySelector('.completion-message').textContent = "No words due right now.";
           return;
        }

        document.getElementById('dueCount').textContent = currentWords.length;
        showCurrentCard();
      } catch (error) { console.error("Error loading words:", error); }
    }

    function showCurrentCard() {
      if (currentIndex >= currentWords.length) {
        switchScreen('completionScreen');
        document.getElementById('summaryTotal').textContent = sessionStats.total;
        document.getElementById('summaryHard').textContent = sessionStats.hard;
        document.getElementById('summaryGood').textContent = sessionStats.good;
        document.getElementById('summaryEasy').textContent = sessionStats.easy;
        if (sessionStats.deleted > 0) {
          document.getElementById('summaryDeletedContainer').style.display = 'block';
          document.getElementById('summaryDeleted').textContent = sessionStats.deleted;
        } else {
          document.getElementById('summaryDeletedContainer').style.display = 'none';
        }
        updateStats();
        return;
      }

      const word = currentWords[currentIndex];
      const progress = ((currentIndex + 1) / currentWords.length) * 100;
      document.getElementById('progressFill').style.width = progress + '%';

      document.getElementById('btnPrevious').disabled = (currentIndex === 0);
      document.getElementById('btnNext').disabled = (currentIndex === currentWords.length - 1);

      document.getElementById('wordFront').textContent = word.word;
      
      const context = word.context || '';
      if (context.includes(word.word)) {
        document.getElementById('contextDisplay').textContent = `"${context}"`;
      } else {
        document.getElementById('contextDisplay').textContent = '';
      }

      document.getElementById('wordDisplay').textContent = word.word;
      document.getElementById('readingDisplay').textContent = word.reading;
      document.getElementById('meaningDisplay').textContent = word.meaning;

      const contextBack = document.getElementById('contextBack');
      if (context.includes(word.word)) {
        document.getElementById('contextSentenceBack').textContent = context;
        document.getElementById('contextTranslation').textContent = word.contextTranslation || '...';
        contextBack.style.display = 'block';
      } else {
        contextBack.style.display = 'none';
      }

      document.getElementById('flashcard').classList.remove('flipped');
      isFlipped = false;
    }

    document.getElementById('flashcard').addEventListener('click', function(e) {
      if (e.target.classList.contains('delete-btn')) return;
      if (!isFlipped) { this.classList.add('flipped'); isFlipped = true; }
    });

    document.getElementById('deleteBtnFront').addEventListener('click', (e) => { e.stopPropagation(); deleteCurrentWord(); });

    async function deleteCurrentWord() {
      const word = currentWords[currentIndex];
      try {
        await fetch(`${firebaseConfig.databaseURL}/users/${currentUserId}/deletedWords/${word.id}.json`, {
          method: 'PUT', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ word: word.word, reading: word.reading, meaning: word.meaning, deletedAt: Date.now() })
        });
        await fetch(`${firebaseConfig.databaseURL}/users/${currentUserId}/words/${word.id}.json`, { method: 'DELETE' });

        currentWords.splice(currentIndex, 1);
        sessionStats.deleted++; sessionStats.total++;
        document.getElementById('dueCount').textContent = currentWords.length;

        if (currentWords.length === 0) {
             switchScreen('completionScreen');
             document.querySelector('.completion-message').textContent = 'All done! Last word deleted.';
        } else {
             if (currentIndex >= currentWords.length) currentIndex = currentWords.length - 1;
             showCurrentCard();
        }
      } catch (error) { console.error('Error deleting word:', error); alert('Failed to delete word'); }
    }

    document.getElementById('btnPrevious').addEventListener('click', () => { if (currentIndex > 0) { currentIndex--; showCurrentCard(); } });
    document.getElementById('btnNext').addEventListener('click', () => { if (currentIndex < currentWords.length - 1) { currentIndex++; showCurrentCard(); } });

    document.addEventListener('keydown', (e) => {
      if (document.getElementById('reviewScreen').style.display === 'block') {
        if (e.key === 'ArrowLeft' && currentIndex > 0) { e.preventDefault(); currentIndex--; showCurrentCard(); }
        if (e.key === 'ArrowRight' && currentIndex < currentWords.length - 1) { e.preventDefault(); currentIndex++; showCurrentCard(); }
      }
    });

    document.getElementById('btnHard').addEventListener('click', () => reviewWord('hard'));
    document.getElementById('btnGood').addEventListener('click', () => reviewWord('good'));
    document.getElementById('btnEasy').addEventListener('click', () => reviewWord('easy'));

    async function reviewWord(difficulty) {
      const word = currentWords[currentIndex];
      const now = Date.now();
      const intervals = { hard: 1, good: 3, easy: 7 };
      const nextReview = now + (intervals[difficulty] * 24 * 60 * 60 * 1000);

      word.lastReviewed = now;
      word.reviewCount = (word.reviewCount || 0) + 1;
      word.difficulty = difficulty;
      word.nextReview = nextReview;
      if (word.reviewCount >= 5 && (difficulty === 'good' || difficulty === 'easy')) word.mastered = true;

      try {
        await fetch(`${firebaseConfig.databaseURL}/users/${currentUserId}/words/${word.id}.json`, {
          method: 'PATCH', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lastReviewed: word.lastReviewed, reviewCount: word.reviewCount, difficulty: word.difficulty, nextReview: word.nextReview, mastered: word.mastered })
        });
      } catch (error) { console.error("Error updating word:", error); }

      sessionStats[difficulty]++; sessionStats.total++; reviewedToday++;
      document.getElementById('reviewedCount').textContent = reviewedToday;
      currentIndex++; showCurrentCard();
    }

    // Generate meaning and usage pattern for a verb using AI
    async function generateVerbInfo(verb) {
      try {
        const apiKey = localStorage.getItem('openaiApiKey');
        if (!apiKey) { 
          console.error('OpenAI API key not found');
          return null;
        }

        const prompt = `You are a Japanese language teacher. For the verb "${verb.word}" (reading: ${verb.reading}), provide:
1. A clear English meaning/translation
2. A natural Japanese example sentence using this verb
3. The English translation of that example sentence

Return ONLY a JSON object in this exact format:
{
  "meaning": "to do something / meaning in English",
  "example": "Ëá™ÁÑ∂„Å™Êó•Êú¨Ë™û„ÅÆ‰æãÊñá",
  "exampleTranslation": "English translation of the example"
}

Be concise and practical. Focus on common, everyday usage.`;

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json', 
            'Authorization': `Bearer ${apiKey}` 
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [{ role: "user", content: prompt }],
            temperature: 0.7,
            max_tokens: 300
          })
        });

        if (!response.ok) throw new Error(`OpenAI API error: ${response.status}`);

        const data = await response.json();
        let aiResponse = data.choices[0].message.content.trim();
        
        // Clean JSON response
        if (aiResponse.startsWith('```json')) {
          aiResponse = aiResponse.replace(/^```json\n/, '').replace(/\n```$/, '');
        } else if (aiResponse.startsWith('```')) {
          aiResponse = aiResponse.replace(/^```\n/, '').replace(/\n```$/, '');
        }

        const verbInfo = JSON.parse(aiResponse);
        return verbInfo;
      } catch (error) {
        console.error('Error generating verb info:', error);
        return {
          meaning: `to ${verb.word}`,
          example: `${verb.word}„Åæ„Åô`,
          exampleTranslation: `Example with ${verb.word}`
        };
      }
    }

    // Seed Firebase with all common verbs and their AI-generated info (run once)
    async function seedCommonVerbs() {
      try {
        console.log('Starting to seed common verbs...');
        const apiKey = localStorage.getItem('openaiApiKey');
        if (!apiKey) {
          alert('OpenAI API key required to seed verbs');
          return;
        }

        // Check if already seeded
        const checkUrl = `${firebaseConfig.databaseURL}/commonVerbs.json`;
        const checkResponse = await fetch(checkUrl);
        const existing = await checkResponse.json();
        
        if (existing && Object.keys(existing).length > 0) {
          console.log('Common verbs already seeded. Skipping...');
          return;
        }

        // Get all verbs from COMMON_VERBS
        if (!COMMON_VERBS || COMMON_VERBS.length === 0) {
          alert('Common verbs data not loaded');
          return;
        }

        let seeded = 0;
        for (let i = 0; i < COMMON_VERBS.length; i++) {
          const verb = COMMON_VERBS[i];
          const verbId = verb.word.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/g, '_').toLowerCase();
          
          // Check if already exists
          const verbUrl = `${firebaseConfig.databaseURL}/commonVerbs/${verbId}.json`;
          const verbCheck = await fetch(verbUrl);
          const verbExists = await verbCheck.json();
          
          if (verbExists && verbExists.meaning) {
            console.log(`Skipping ${verb.word} (already seeded)`);
            continue;
          }

          // Generate AI info
          console.log(`Generating AI info for ${verb.word} (${i+1}/${COMMON_VERBS.length})...`);
          const verbInfo = await generateVerbInfo(verb);
          
          if (verbInfo) {
            const verbData = {
              word: verb.word,
              reading: verb.reading,
              meaning: verbInfo.meaning,
              context: verbInfo.example,
              contextTranslation: verbInfo.exampleTranslation,
              seededAt: Date.now()
            };
            
            // Save to Firebase
            await fetch(verbUrl, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(verbData)
            });
            
            seeded++;
            console.log(`Seeded ${verb.word} (${seeded}/${COMMON_VERBS.length})`);
            
            // Small delay to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }
        
        console.log(`Seeding complete! Seeded ${seeded} verbs.`);
        alert(`Seeded ${seeded} common verbs with AI usage patterns!`);
      } catch (error) {
        console.error('Error seeding verbs:', error);
        alert('Error seeding verbs: ' + error.message);
      }
    }

    // Load common verbs practice session (loads from Firebase, no AI calls)
    async function loadCommonVerbsPractice() {
      try {
        if (!COMMON_VERBS || COMMON_VERBS.length === 0) {
          alert('Common verbs data not loaded. Please refresh the page.');
          return;
        }

        // Show loading message
        switchScreen('reviewScreen');
        document.getElementById('wordFront').textContent = 'Loading verbs...';
        document.getElementById('contextDisplay').textContent = 'Loading from database...';

        // Load all seeded verbs from Firebase
        const seedUrl = `${firebaseConfig.databaseURL}/commonVerbs.json`;
        const seedResponse = await fetch(seedUrl);
        const seededVerbs = await seedResponse.json();

        if (!seededVerbs || Object.keys(seededVerbs).length === 0) {
          // Not seeded yet - seed them now
          alert('Common verbs not seeded yet. Seeding now (this will take a few minutes)...');
          await seedCommonVerbs();
          // Reload after seeding
          await loadCommonVerbsPractice();
          return;
        }

        // Get user's existing words to check which verbs they've already learned
        const url = `${firebaseConfig.databaseURL}/users/${currentUserId}/words.json`;
        const response = await fetch(url);
        const existingWords = await response.json();
        const existingWordSet = existingWords ? new Set(Object.values(existingWords).map(w => w.word)) : new Set();

        // Convert seeded verbs to array and filter
        const allSeededVerbs = Object.values(seededVerbs);
        const verbsToPractice = allSeededVerbs
          .filter(v => !existingWordSet.has(v.word)) // Prefer verbs not already learned
          .sort(() => Math.random() - 0.5)
          .slice(0, 20);

        if (verbsToPractice.length === 0) {
          // If all verbs are already learned, just pick random ones
          verbsToPractice.push(...allSeededVerbs.sort(() => Math.random() - 0.5).slice(0, 20));
        }

        // Create word objects from seeded data (no AI calls needed!)
        currentWords = [];
        for (let i = 0; i < verbsToPractice.length; i++) {
          const seededVerb = verbsToPractice[i];
          const wordId = seededVerb.word.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/g, '_').toLowerCase();
          
          // Check if word already exists in user's vocabulary
          const existingWord = existingWords && existingWords[wordId];
          
          if (existingWord) {
            // Use existing word data
            currentWords.push({
              id: wordId,
              ...existingWord
            });
          } else {
            // Create new word object from seeded data
            const newWord = {
              id: wordId,
              word: seededVerb.word,
              reading: seededVerb.reading,
              meaning: seededVerb.meaning,
              context: seededVerb.context,
              contextTranslation: seededVerb.contextTranslation,
              platform: 'common_verbs',
              show: 'Common Verbs',
              season: null,
              episode: null,
              savedAt: Date.now(),
              lastReviewed: null,
              nextReview: Date.now(),
              reviewCount: 0,
              difficulty: 'new',
              timesEncountered: 1,
              mastered: false
            };
            
            // Save to user's words in Firebase
            try {
              await fetch(`${firebaseConfig.databaseURL}/users/${currentUserId}/words/${wordId}.json`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newWord)
              });
            } catch (error) {
              console.error('Error saving verb to Firebase:', error);
            }
            
            currentWords.push(newWord);
          }
          
          // Update progress indicator
          const progress = ((i + 1) / verbsToPractice.length) * 100;
          document.getElementById('progressFill').style.width = progress + '%';
        }

        if (currentWords.length === 0) {
          alert('Failed to load verbs. Please try again.');
          switchScreen('showListScreen');
          return;
        }

        // Initialize session
        sessionStats = { hard: 0, good: 0, easy: 0, deleted: 0, total: 0 };
        currentIndex = 0;
        reviewedToday = 0;
        document.getElementById('dueCount').textContent = currentWords.length;
        document.getElementById('reviewedCount').textContent = 0;

        showCurrentCard();
      } catch (error) {
        console.error('Error loading common verbs practice:', error);
        alert('Error: ' + error.message);
        switchScreen('showListScreen');
      }
    }

    async function updateStats() {
      try {
        await fetch(`${firebaseConfig.databaseURL}/users/${currentUserId}/stats.json`, {
          method: 'PATCH', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reviewedToday: reviewedToday, lastReviewDate: Date.now() })
        });
      } catch (e) { console.error(e); }
    }

    window.handleContinue = function() { switchScreen('showListScreen'); loadShowList(); };
    function getCookie(name) { const v = `; ${document.cookie}`; const p = v.split(`; ${name}=`); if (p.length === 2) return decodeURIComponent(p.pop().split(';').shift()); return null; }

    if (initFirebase()) {
      let u = localStorage.getItem('savedUserId') || getCookie('savedUserId');
      let k = localStorage.getItem('openaiApiKey') || getCookie('openaiApiKey');
      if (u && k) { currentUserId = u; document.getElementById('userIdInput').value = u; document.getElementById('apiKeyInput').value = k; switchScreen('showListScreen'); loadShowList(); }
      else if (u) { document.getElementById('userIdInput').value = u; switchScreen('loginScreen'); }
    }
  </script>
</body>
</html>
